#!/usr/bin/env node

var secrets = require('../config/secrets');
var mongoose = require('mongoose');

// Data Models
var DataSource = require('../models/dataSource');
var TapListing = require('../models/tapListing');

// Scraper modules
var chucksGreenwood = require('../scrapers/chucksGreenwood');
var chucksCentralDistrict = require('../scrapers/chucksCentralDistrict');
var theYardCafe = require('../scrapers/theYardCafe');
var theDray = require('../scrapers/theDray');
var uber = require('../scrapers/uber');
var nakedCity = require('../scrapers/nakedCity');
var prostTavern = require('../scrapers/prostTavern');
var theNobleFir = require('../scrapers/theNobleFir');
var theSixgill = require('../scrapers/theSixgill');
var theBarkingDog = require('../scrapers/theBarkingDog');
var thePineBox = require('../scrapers/thePineBox');
var toronadoSeattle = require('../scrapers/toronadoSeattle');

var async = require('async');

mongoose.connect((process.env.NODE_ENV && process.env.NODE_ENV === 'test') ?
    secrets.db.test :
    secrets.db.production);

var scrapers = {
    'chucksGreenwood': chucksGreenwood,
    'chucksCentralDistrict': chucksCentralDistrict,
    'theYardCafe': theYardCafe,
    'theDray': theDray,
    'uber': uber,
    'nakedCity': nakedCity,
    'prostTavern': prostTavern,
    'theNobleFir': theNobleFir,
    'theSixgill': theSixgill,
    'theBarkingDog': theBarkingDog,
    'thePineBox': thePineBox,
    'toronadoSeattle': toronadoSeattle
};

function scrapeDataSources(callback) {
    DataSource.find({}, function(err, dataSources) {
        if (err) {
            console.log('ERROR: Failed to read data sources from the database');
            return callback();
        }

        async.eachSeries(dataSources, function(dataSource, itrCallback) {
            console.log('Updating data source: ' + dataSource.name);

            var scraper = scrapers[dataSource.scraper];
            scraper.scrapeSite(function(err, beers) {
                if (err) {
                    console.log('ERROR: Failed to scrape ' + dataSource.name);
                    console.dir(err);
                    return itrCallback();
                }

                if (beers.length == 0) {
                    // If we didn't get *any* beers, then something probably went wrong
                    console.log('ERROR: Found no beers at ' + dataSource.name);
                    return itrCallback();
                }

                storeBeers(dataSource, beers, itrCallback);
            });
        }, function(err) {
            console.log('Finished updating data sources');
            callback();
        });
    });
};

function storeBeers(dataSource, beers, callback) {
    TapListing.find({ dataSource: dataSource, isActive: true }, function(err, currentListings) {
        var newListings = beers.filter(function(newBeer) {
            return !currentListings.some(function(currentTap) {
                return currentTap.rawListing.trim() === newBeer.trim();
            });
        });

        var removedListings = currentListings.filter(function(currentTap) {
            return !beers.some(function(newBeer) {
                return newBeer.trim() === currentTap.rawListing.trim();
            });
        });

        var operations = [];

        for (var i = 0; i < newListings.length; i++) {
            console.log(' + ' + newListings[i]);
            operations.push({ listing: newListings[i], type: 'add' });
        }

        for (var i = 0; i < removedListings.length; i++) {
            console.log(' - ' + removedListings[i].rawListing);
            operations.push({ listing: removedListings[i], type: 'remove' });
        }

        async.eachSeries(operations, function(operation, itrCallback) {
            switch(operation.type) {
                case 'add':
                    var newTapListing = new TapListing();
                    newTapListing.rawListing = operation.listing;
                    newTapListing.dataSource = dataSource;
                    newTapListing.createdDate = new Date();
                    newTapListing.isActive = true;

                    newTapListing.save(function(err, listing) {
                        if (err) {
                            console.log('ERROR: Error saving tap listing: ' + listing.rawListing);
                            console.dir(err);
                            return itrCallback();
                        }

                        return itrCallback();
                    });
                    break;

                case 'remove':
                    operation.listing.removedDate = new Date();
                    operation.listing.isActive = false;

                    operation.listing.save(function(err, listing) {
                        if (err) {
                            console.log('ERROR: Error updating removed tap listing: ' + listing.rawListing);
                            console.dir(err);
                            return itrCallback();
                        }

                        return itrCallback(); 
                    });
                    break;
                };
        }, function(err) {
            console.log('Finished updating tap listings for ' + dataSource.name + '\n');

            if (operations.length == 0) {
                return callback();
            }

            dataSource.update({ $push: { updates: new Date() }}, function(err, item) {
                if (err) {
                    console.log('ERROR: Error adding update timestamp to dataSource!');
                }

                return callback();
            });
        });
    });
};

async.series([
    function(callback) {
        scrapeDataSources(callback);
    }
], function() {
    process.exit();
});
